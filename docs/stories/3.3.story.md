# Story 3.3: Create Character Model

### **Status**
- Draft

### **Story**
**As a** developer,
**I want** a form to define a new character model,
**so that** I can set up the templates for in-game characters or NFTs.

### **Acceptance Criteria**
1.  On the project detail page, there is a "Create Character Model" button.
2.  The form allows the user to select a configuration `kind`: "Wrapped" or "Assembled".
3.  If "Wrapped" is selected, the form provides fields to define the `criterias` for wrapping (e.g., by Merkle Tree, Collection, or Creator).
4.  If "Assembled" is selected, the form provides fields to input the `assemblerConfigInput`.
5.  Submitting the form uses the `createCreateCharacterModelTransaction` GraphQL mutation with the correct payload.
6.  The user is prompted to sign the transaction, and appropriate success/error feedback is provided.

### **Tasks / Subtasks**
* **Frontend (app/client)**
    * [ ] Add a "Character Models" section to the project detail page with a "Create Character Model" button. (AC: 1)
    * [ ] Create a modal form for creating a new character model. (AC: 2)
    * [ ] The form must include a radio button or select input for the `kind` ("Wrapped" or "Assembled"). (AC: 2)
    * [ ] Implement conditional rendering in the form:
        * If `kind` is "Wrapped", display inputs for `criterias`. (AC: 3)
        * If `kind` is "Assembled", display inputs for `assemblerConfigInput`. (AC: 4)
    * [ ] Add client-side validation for the dynamic form fields.
    * [ ] Create an API service function to call the BFF's `POST /api/projects/{projectId}/character-models` endpoint. (AC: 5)
    * [ ] Implement the client-side transaction signing flow. (AC: 6)
    * [ ] On success, show a confirmation message and clear the form. (The list will be refreshed in Story 3.4). (AC: 6)
* **Backend (app/server)**
    * [ ] Create a new route handler for `POST /api/projects/{projectId}/character-models`. (AC: 5)
    * [ ] In the handler, call the `@honeycomb-protocol/edge-client`'s `createCreateCharacterModelTransaction` method.
    * [ ] Ensure the `config` payload sent to the client is correctly structured based on the `kind` received from the frontend.
    * [ ] Return the serialized transaction to the client.
    * [ ] Implement standard error handling.

### **Dev Notes**
* The key challenge in this story is the **conditional UI** on the frontend. The form must dynamically change based on whether the user is creating a "Wrapped" or "Assembled" character model.
* The backend must correctly construct the `config` object for the `createCreateCharacterModelTransaction` call. Refer to the Honeycomb Protocol API documentation for the exact structure of the `criterias` and `assemblerConfigInput` objects.
* The successful creation will be confirmed via a toast notification. The UI to display the list of created models will be built in the next story (3.4).

### **Testing**
* **Frontend**:
    * Write component tests for the form's conditional rendering logic. Verify that selecting "Wrapped" shows the criteria fields and selecting "Assembled" shows the assembler config fields.
* **Backend**:
    * Write two separate integration tests for the new endpoint: one testing the creation of a "Wrapped" model and another for an "Assembled" model, ensuring the correct payload is passed to the mocked Honeycomb client in each case.

### **Change Log**
| Date       | Version | Description   | Author       |
| :--------- | :------ | :------------ | :----------- |
| 2025-07-23 | 1.0     | Initial draft | Scrum Master |